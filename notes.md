# Вопросы
* CurrIndent (имею ввиду currentIndent) это подходящее сокращение ?

* Это нормально то, что root увеличвает глубину на 1 (depth + 1), a nested на 2 (depth + 2) ?

* Можно ди сделать вот такое обобщение:
```
const prefix = `${indent.repeat(depth)}${actionPrefix}`;
// Затем уже собирать строку
const row = `${prefix}${diffNode.key}: ${value}`;
```

* В реалии как происходит код ревью? Через gitHub? Где ревьювер оставляет замечания которые мне надо будет поправить?
* Где я могу задавать вопросы по замечаниям ревьювера?
* Полагаю что коммерческая разаработка ведеться в приватных репозиториях?
* Какие для этого используют сервисы помимо gitHub ?

***************** 22 01 21 ******************

https://github.com/alex-ismailov/frontend-project-lvl2/blob/3f0239efe2eaee8e339d6acc123d2aef71228063/src/differ.js#L28-L42
Это пожалуй наиболее критичное замечание из всех. Мы уже обсуждали сложность логики здесь, но в итоге я не дожал. Итак, проблемы логики следующие:

Сначала мы проверяем, являются значения по ключу key объектами (стр 28), а ниже проверяем есть ли такой ключ вообще.
То же самое на строке 34. Сначала проверяем наличие ключа в обоих объектах, а потом на 40й проверяем есть ли ключ в объекте 1.

Насколько я понимаю в первую очередь правильно проверить, а есть ли такие ключи вообще в объекте.
Если я так делаю, то у меня неизбежно возникают вложенные if-ы, первый на случай если оба значения по ключу являются объектами. Второй if на случай если оба значения по ключу идентичны.

Пока я имею вот такую структуру из if-ов:
```
sortedKeysUnion.map((key) => {
  if (_.has(obj1, key) && _.has(obj2, key)) {
    if (_.isPlainObject(obj1[key]) && _.isPlainObject(obj2[key])) {
      return { key, type: 'nested', children: getDiffTreeChildren(obj1[key], obj2[key]) };
    }
    if (_.isEqual(obj1[key], obj2[key])) {
      return { key, type: 'unchanged', value: obj1[key] };
    }
    return {
      key, type: 'updated', currentValue: obj2[key], previousValue: obj1[key],
    };
  }

  return _.has(obj1, key)
    ? { key, type: 'removed', value: obj1[key] }
    : { key, type: 'added', value: obj2[key] };
});
```
Такой вариант подходит?
Или вложенные if-ы это стоп фактор и их надо всегда избегать?
Это место вообще как-то можно решить без вложенных if, не учитывая мое предыдущее решение (не совсем корректное)?

*************************************************************
********************** Не срочно *************************
https://github.com/alex-ismailov/frontend-project-lvl2/blob/3f0239efe2eaee8e339d6acc123d2aef71228063/__tests__/differ.test.js#L14-L15
В этих местах относительный путь все равно нужно формировать через path.resolve, чтобы не было проблем со слэшами в разных ОС.

Возможно я не до конца понимаю, но в этом месте я специально указал относительные пути (относительно корня проекта). Таким образом я хотел протестировать утилиту на то, что она корректно отрабатывает если на вход ей дать относительные пути. (Хоть как мне и кажется ситуация очень искусственная)

Об этом говорилось в подсказках на 3 шаге:
“Программа должна уметь работать как с относительными, так и абсолютными путями до файлов (полезные функции: path.resolve() и process.cwd()).”

Если я буду использовать path.resolve при формировании пути, то по факту я заранее сформирую абосолютный путь до файла, и на вход утилита сразу получит абослютный путь, а не относительный.

Этот тест вообще нужен? Я его удалил.

Вряд ли в реальной жизни утилиту будут запускать из директории в которую она установленна, и подавать пути до файлов из той же самой директории.
А если утилиту будут использовать как пакет (в идеале как npm пакет через install и import), то файлы очень мало вероятно будут лежат вместе с пакетом в node_modules.


*************************************************************
Как правильно переводится на русский яз. Reduce, если говорить в контексте функции reduce.
Google дает перевод: уменьшить, снижать, сокращать. Но ведь на выходе мы можем получить то же самое кол-во элементов в получаемой структуре.
Еще есть перевод: приводить, превращать.
Я не до конца понимаю семантику reduce.
Для меня основная фича этой функции это то, что мы можем сформровать любой тип данных на выходе, т.е. преобразовать его в удобный для нас тип данных.
Можешь мне объяснить в каких ситуациях будет уместно применять reduce ?

*************************************************************
https://github.com/alex-ismailov/frontend-project-lvl2/blob/3f0239efe2eaee8e339d6acc123d2aef71228063/src/differ.js#L3-L5
Вроде мелочь, но лучше поправить, чтобы было совсем красиво. Итого, речь идет о единстве стиля при импорте lodash. Где-то это import _ from 'lodash';, а где-то import isObjectLike from 'lodash/isObjectLike.js';. В качестве решения предлагаю использовать везде import _ from 'lodash';, но при этом отказаться и от деструктуризации, как это сделано по сслыке над абзацем, т.е. вызывать функции через _.methodName, например _.has(...).

Получается стиль превыше практичности?
Когда я писал эти импорты, то руководствовался вот этой статьей:
https://habr.com/ru/company/ruvds/blog/502424/
т.е. изначально я не стал тянуть весь lodash целиком.
Понимаю что ранняя оптимизация это не очень хорошо, но здесь ведь ничего сложного.

*************************************************************


# Заметки

tab.repeat(depth) + '  '.repeat(depth – 1);

Каждому уровню вложенности помимо таба мы добав двойно йпробел для компесации занка дифа
Кроме 1 , у рута нет знака дифа

Так как нода рут не имеет знака диф в отличие от остальных нод, то для сохранения визуальной вложенности мы компенсируем дополнительный отступ за счет добавления двойного пробела. Кроме ноды рут.




--------------------------------------------------------------
Глуб – 1 повтор символов пустой .
(Depth * tab ) + символ характеризующий строку

(Depth * tab ) +


есть таки еданные
можно ли им доверять

locale storage - .

IndexDB – не

Стек обычно состоит из фреймворков
JavaScript? Nodejs/


goodFirstIssue – ишью для джунов

jerra -
scram время
sprint

Pull request – draft


**********************************************
Допустим:

* ( звездочка ) это пробел.

# (решетка) это префикс для nested

‘+_‘ это префикс для added

‘-_’ это префикс для removed

‘^^’ это префикс для unchanged


Когда через root я погружаюсь на 1 уровень глубже, получается так
отступ 2 пробела
```
{
**##common: {

Далее  через nested я погружаюсь еще на 1 уровень глубже
отступ 4 пробела:

****??+_follow: false

Затем еще на 1 уровень глубже через nested:
отступ 6 пробела

****??+-setting6: {
******????##doge: {

Затем еще на 1 уровень глубже через nested:
отступ 8 пробелов:

********??????-_wow:
********??????+_wow: so much
```
итоге:
```
{
**##common: { // 2
****??+_follow: false // 6
****??+-setting6: { // 6
******????##doge: { // 10
********??????-_wow: // 14
********??????+_wow: so much // 14
```
root + 2 пробела; nested + 4 пробела


***************************************************
```
{ // 0
**##common: { // 2
****??+_follow: false // 6
****??+_setting6: { // 6
******????##doge: { // 10
********??????-_wow: // 14
********??????+_wow: so much // 14
******????##} // 10
****??+_} // 6
**##} // 2
**+_group3: { // 2
****??^^deep: { // 6
******????^^id: { // 10
********??????^^number: 45 // 14
******????^^} // 10
****??^^} // 6
**??} // 2
} // 0
```

0 – 2 – 6 – 10 – 14

***************************************************************
*  0 – 1 – 3 – 5 – 7  // root + 1 indent, nested + 2 indents  *
***************************************************************


****************************************************
deffTree:
{
  "type": "root",
  "children": [
    {
      "key": "common",
      "type": "nested",
      "children": [
        {
          "key": "follow",
          "type": "added",
          "value": false
        },
        {
          "key": "setting1",
          "type": "unchanged",
          "value": "Value 1"
        },
        {
          "key": "setting2",
          "type": "removed",
          "value": 200
        },
        {
          "key": "setting3",
          "type": "updated",
          "value": null,
          "valueBefore": true
        },
        {
          "key": "setting4",
          "type": "added",
          "value": "blah blah"
        },
        {
          "key": "setting5",
          "type": "added",
          "value": {
            "key5": "value5"
          }
        },
        {
          "key": "setting6",
          "type": "nested",
          "children": [
            {
              "key": "doge",
              "type": "nested",
              "children": [
                {
                  "key": "wow",
                  "type": "updated",
                  "value": "so much",
                  "valueBefore": ""
                }
              ]
            },
            {
              "key": "key",
              "type": "unchanged",
              "value": "value"
            },
            {
              "key": "ops",
              "type": "added",
              "value": "vops"
            }
          ]
        }
      ]
    },
    {
      "key": "group1",
      "type": "nested",
      "children": [
        {
          "key": "baz",
          "type": "updated",
          "value": "bars",
          "valueBefore": "bas"
        },
        {
          "key": "foo",
          "type": "unchanged",
          "value": "bar"
        },
        {
          "key": "nest",
          "type": "updated",
          "value": "str",
          "valueBefore": {
            "key": "value"
          }
        }
      ]
    },
    {
      "key": "group2",
      "type": "removed",
      "value": {
        "abc": 12345,
        "deep": {
          "id": 45
        }
      }
    },
    {
      "key": "group3",
      "type": "added",
      "value": {
        "fee": 100500,
        "deep": {
          "id": {
            "number": 45
          }
        }
      }
    }
  ]
}
